{
  "name": "zform",
  "type": "registry:block",
  "registryDependencies": [
    "alert",
    "badge",
    "button",
    "calendar",
    "checkbox",
    "form",
    "input",
    "label",
    "popover",
    "select",
    "switch",
    "textarea"
  ],
  "files": [
    {
      "path": "./zform/context.ts",
      "content": "import { createContext, useContext } from \"react\";\nimport { ParsedField, ParsedSchema, ZodObjectOrWrapped } from \"./core/types\";\nimport { Config, FieldConfig } from \"./types\";\n\nimport { getDescriptions, getLabel } from \"./core/parser\";\nimport { getBooleanFieldComponent } from \"./components/boolean-field\";\nimport { getSelectFieldComponent } from \"./components/select-field\";\nimport { getDateFieldComponent } from \"./components/date-field\";\nimport { getNumberFieldComponent } from \"./components/number-field\";\nimport { getStringFieldComponent } from \"./components/string-field\";\nimport { getArrayFieldComponent } from \"./components/array-field\";\nimport { getObjectFieldComponent } from \"./components/object-field\";\n\nexport type ZContextType<\n  TSchema extends ZodObjectOrWrapped = ZodObjectOrWrapped\n> = ParsedSchema & {\n  config: Config<TSchema>;\n};\nconst ZFormContext = createContext<ZContextType | null>(null);\n\nexport const ZFormProvider = ZFormContext.Provider;\n\nexport function useZForm() {\n  const context = useContext(ZFormContext);\n  if (!context) {\n    throw new Error(\"useZForm must be used within an ZFormProvider\");\n  }\n\n  return context;\n}\nexport function useZField(field: ParsedField, path: string[]) {\n  const { config } = useZForm();\n\n  function getFieldConfig(): FieldConfig & {\n    fieldLabel: string;\n    fieldDescription?: string;\n  } {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let currentConfig: any = config;\n\n    // Traverse the config based on the path\n    for (const segment of path) {\n      if (!currentConfig) break;\n\n      // Handle array indices by generalizing to the array level\n      if (Number.isInteger(Number(segment))) {\n        // If the current segment is an index, move up to the array level\n        if (\"*\" in currentConfig) {\n          currentConfig = currentConfig[\"*\"];\n        }\n        continue; // Skip numeric indices\n      }\n\n      // Move to the next nested configuration\n      currentConfig = currentConfig[segment];\n    }\n    // Extract overrides if the resolved configuration exists\n    if (currentConfig) {\n      const { labelOverride, descriptionOverride, ...other } = currentConfig;\n      return {\n        fieldLabel: labelOverride || getLabel(field),\n        fieldDescription: descriptionOverride || getDescriptions(field),\n        ...other,\n      };\n    }\n\n    return {\n      fieldLabel: getLabel(field),\n      fieldDescription: getDescriptions(field),\n    };\n  }\n\n  const getFieldComponent = (typeOverride?: string) => {\n    switch (field.type) {\n      case \"string\":\n        return getStringFieldComponent(typeOverride as \"password\" | \"textarea\");\n      case \"boolean\":\n        return getBooleanFieldComponent(typeOverride as \"switch\");\n      case \"select\":\n        return getSelectFieldComponent(typeOverride as \"autocomplete\");\n      case \"date\":\n        return getDateFieldComponent(typeOverride as \"range\");\n      case \"number\":\n        return getNumberFieldComponent(typeOverride as \"stepper\");\n      case \"array\":\n        return getArrayFieldComponent(typeOverride as \"badges\");\n      case \"object\":\n        return getObjectFieldComponent(typeOverride as \"range\");\n      default:\n        return null;\n    }\n  };\n  const fieldConfig = getFieldConfig();\n  const FieldComponent = getFieldComponent(fieldConfig.typeOverride);\n  return { name: path.join(\".\"), FieldComponent, ...fieldConfig };\n}\n",
      "type": "registry:block",
      "target": "~/zform/context.ts"
    },
    {
      "path": "./zform/field.tsx",
      "content": "import React from \"react\";\nimport { useFormContext } from \"react-hook-form\";\n\nimport {\n  FormControl,\n  FormDescription,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"@/components/ui/form\";\n\nimport { Alert, AlertDescription, AlertTitle } from \"@/components/ui/alert\";\nimport { AlertCircle } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { ZFieldProps } from \"./types\";\nimport { useZField } from \"./context\";\n\nexport const ZField: React.FC<ZFieldProps> = ({ field, path }) => {\n  const {\n    FieldComponent,\n    name,\n    className,\n    fieldLabel,\n    fieldDescription,\n    typeOverride,\n  } = useZField(field, path);\n  const { control } = useFormContext();\n\n  if (!FieldComponent)\n    return (\n      <Alert variant=\"destructive\" className=\"h-full\">\n        <AlertCircle className=\"size-4\" />\n        <AlertTitle>Unhandled field type {field.type}</AlertTitle>\n        <AlertDescription> - {field.key}</AlertDescription>\n      </Alert>\n    );\n  if (field.type === \"array\")\n    return <FieldComponent field={field} path={path} />;\n  if (field.type === \"object\" && typeOverride !== \"range\")\n    return <FieldComponent field={field} path={path} />;\n  if (field.type === \"boolean\")\n    return (\n      <FormField\n        name={name}\n        control={control}\n        render={() => (\n          <FormItem\n            className={cn(\n              \"flex flex-row justify-start space-x-3 space-y-0\",\n              className\n            )}\n          >\n            <FormControl>\n              <FieldComponent field={field} path={path} />\n            </FormControl>\n\n            <div className=\"space-y-1 leading-none\">\n              <FormLabel>{fieldLabel}</FormLabel>\n              <FormDescription>{fieldDescription}</FormDescription>\n              <FormMessage />\n            </div>\n          </FormItem>\n        )}\n      />\n    );\n  return (\n    <FormField\n      name={name}\n      control={control}\n      render={() => (\n        <FormItem className={className}>\n          <FormLabel>{fieldLabel}</FormLabel>\n          <FormControl>\n            <FieldComponent field={field} path={path} />\n          </FormControl>\n          <FormDescription>{fieldDescription}</FormDescription>\n          <FormMessage />\n        </FormItem>\n      )}\n    />\n  );\n};\n",
      "type": "registry:block",
      "target": "~/zform/field.tsx"
    },
    {
      "path": "./zform/form.tsx",
      "content": "\"use client\";\nimport React, { useEffect } from \"react\";\nimport { useForm, DefaultValues } from \"react-hook-form\";\nimport { z } from \"zod\";\nimport { ZFormProvider } from \"./context\";\nimport { Form } from \"@/components/ui/form\";\nimport { Button } from \"@/components/ui/button\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { getDefaultValues, parseSchema } from \"./core/parser\";\nimport { ZField } from \"./field\";\nimport { ZFormProps } from \"./types\";\nimport { ZodObjectOrWrapped } from \"./core/types\";\n\nexport function ZForm<TSchema extends ZodObjectOrWrapped>({\n  schema: inputSchema,\n  defaultValues,\n  children,\n  onSubmit = () => {},\n  withSubmit = false,\n  withReset = false,\n  onFormInit = () => {},\n  formProps = {},\n  config = {},\n  submitProps = {},\n  resetProps = {},\n  header,\n  footer,\n}: ZFormProps<TSchema>) {\n  const { fields, schema } = parseSchema(inputSchema);\n  const form = useForm<z.infer<typeof schema>>({\n    resolver: zodResolver(schema),\n    defaultValues:\n      defaultValues ||\n      (getDefaultValues(schema) as DefaultValues<z.infer<TSchema>>),\n  });\n\n  useEffect(() => {\n    if (onFormInit) {\n      onFormInit(form);\n    }\n  }, [onFormInit, form]);\n\n  return (\n    <Form {...form}>\n      <ZFormProvider\n        value={{\n          fields,\n          schema,\n          config,\n        }}\n      >\n        <div className=\"flex flex-col gap-4 max-w-screen-sm w-full\">\n          {header}\n          <form onSubmit={form.handleSubmit(onSubmit)} {...formProps}>\n            {fields.map((field, index) => (\n              <ZField\n                key={`field-${index}-${field.key}`}\n                field={field}\n                path={[field.key]}\n              />\n            ))}\n\n            {children}\n\n            {withReset && (\n              <Button\n                type=\"button\"\n                {...resetProps}\n                onClick={() =>\n                  form.reset(defaultValues || getDefaultValues(schema))\n                }\n              >\n                Reset\n              </Button>\n            )}\n            {withSubmit && (\n              <Button type=\"submit\" {...submitProps}>\n                Submit\n              </Button>\n            )}\n          </form>\n          {footer}\n        </div>\n      </ZFormProvider>\n    </Form>\n  );\n}\n",
      "type": "registry:block",
      "target": "~/zform/form.tsx"
    },
    {
      "path": "./zform/index.ts",
      "content": "import { ZForm } from \"./form\";\n\nexport * from \"./types\";\nexport default ZForm;\n",
      "type": "registry:block",
      "target": "~/zform/index.ts"
    },
    {
      "path": "./zform/types.ts",
      "content": "import { Button } from \"@/components/ui/button\";\nimport { ReactNode } from \"react\";\nimport { DefaultValues, SubmitHandler, UseFormReturn } from \"react-hook-form\";\nimport { z } from \"zod\";\nimport { CalendarProps } from \"@/components/ui/calendar\";\nimport { FieldType, ParsedField, ZodObjectOrWrapped } from \"./core/types\";\nimport { SelectProps } from \"@radix-ui/react-select\";\nimport { CheckboxProps } from \"@radix-ui/react-checkbox\";\nimport { SwitchProps } from \"@radix-ui/react-switch\";\n\ninterface ZFormBaseProps<TSchema extends ZodObjectOrWrapped> {\n  schema: TSchema;\n  defaultValues?: DefaultValues<z.infer<TSchema>>;\n  onSubmit?: SubmitHandler<z.infer<TSchema>>;\n  onFormInit?: (\n    form: UseFormReturn<z.infer<TSchema>, unknown, undefined>\n  ) => void;\n}\n\ninterface ZFormComponentsProps {\n  formProps?: Omit<React.ComponentProps<\"form\">, \"onSubmit\">;\n  submitProps?: Omit<React.ComponentProps<typeof Button>, \"type\" | \"asChild\">;\n  resetProps?: Omit<React.ComponentProps<typeof Button>, \"type\" | \"asChild\">;\n  children?: ReactNode;\n  header?: ReactNode;\n  footer?: ReactNode;\n  withSubmit?: boolean;\n  withReset?: boolean;\n}\n\ntype BaseFieldConfig = {\n  labelOverride?: string;\n  descriptionOverride?: string;\n  className?: string;\n  // array item\n  itemClassName?: string;\n};\n\nexport type FieldConfig = BaseFieldConfig & {\n  inputProps?: React.ComponentProps<\"input\">;\n  typeOverride?:\n    | \"password\"\n    | \"textarea\"\n    | \"autocomplete\"\n    | \"stepper\"\n    | \"switch\"\n    | \"range\";\n  textareaProps?: React.ComponentProps<\"textarea\">;\n  calendarProps?: CalendarProps;\n  selectProps?: SelectProps;\n  checkboxProps?: CheckboxProps;\n  switchProps?: SwitchProps;\n};\nexport interface ZWrapperProps {\n  type: FieldType;\n  name: string;\n  label: string;\n  description: string;\n  className?: string;\n}\n\nexport type ZFieldProps<T = FieldType> = {\n  field: ParsedField<T>;\n  path: string[];\n};\nexport type Config<T> = T extends z.ZodEffects<infer Inner>\n  ? Config<Inner>\n  : T extends z.ZodObject<infer Shape>\n  ? {\n      [K in keyof Shape]?: Config<Shape[K]> | FieldConfig;\n    }\n  : T extends z.ZodArray<infer Element>\n  ? Config<Element> | FieldConfig\n  : FieldConfig;\n\nexport interface ZFormProps<TSchema extends ZodObjectOrWrapped>\n  extends ZFormBaseProps<TSchema>,\n    ZFormComponentsProps {\n  config?: Config<TSchema> | object;\n}\n",
      "type": "registry:block",
      "target": "~/zform/types.ts"
    },
    {
      "path": "./zform/components/array-field.tsx",
      "content": "import React from \"react\";\nimport { useFieldArray, useFormContext } from \"react-hook-form\";\n\nimport { ParsedField } from \"../core/types\";\nimport { ZField } from \"../field\";\nimport { Button } from \"@/components/ui/button\";\nimport { PlusIcon, TrashIcon } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { useZField } from \"../context\";\n\nexport const ArrayField: React.FC<{\n  field: ParsedField;\n  path: string[];\n}> = ({ field, path }) => {\n  const { className, fieldLabel, fieldDescription, name, itemClassName } =\n    useZField(field, path);\n  const { control, getFieldState } = useFormContext();\n  const { fields, append, remove } = useFieldArray({\n    control,\n    name,\n  });\n\n  const defaultValue = field.schema?.[0].default;\n  const { error } = getFieldState(name);\n  const errorMessage = error?.message || error?.root?.message;\n\n  return (\n    <fieldset className={className}>\n      <legend className=\"p-2 flex justify-between gap-2\">\n        <div>\n          <p className=\"font-semibold \">{fieldLabel} </p>\n          <p className=\"text-sm text-muted-foreground\">{fieldDescription}</p>\n          {errorMessage && (\n            <p className=\"text-sm font-medium text-destructive\">\n              {errorMessage}\n            </p>\n          )}\n        </div>\n\n        <Button\n          onClick={() => append(defaultValue)}\n          variant=\"outline\"\n          size=\"sm\"\n          type=\"button\"\n          className=\"\"\n        >\n          <PlusIcon className=\"size-4\" />\n          Add\n        </Button>\n      </legend>\n\n      {fields.map(({ id }, index) => (\n        <div key={id} className={cn(\"relative p-2\", itemClassName)}>\n          <Button\n            onClick={() => remove(index)}\n            variant=\"ghost\"\n            size=\"icon\"\n            type=\"button\"\n            className=\"absolute -top-2 -right-2\"\n          >\n            <TrashIcon className=\"size-4 text-destructive\" />\n          </Button>\n          <ZField\n            field={field.schema![0]!}\n            path={[...path, index.toString()]}\n          />\n        </div>\n      ))}\n    </fieldset>\n  );\n};\nexport const getArrayFieldComponent = (typeOverride?: \"badges\") => {\n  if (typeOverride === \"badges\")\n    throw new Error(\"Not implemented\", { cause: { typeOverride } });\n  return ArrayField;\n};\n",
      "type": "registry:block",
      "target": "~/zform/components/array-field.tsx"
    },
    {
      "path": "./zform/components/boolean-field.tsx",
      "content": "import React from \"react\";\nimport { useFormContext } from \"react-hook-form\";\n\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { ParsedField } from \"../core/types\";\nimport { useFormField } from \"@/components/ui/form\";\nimport { ZFieldProps } from \"../types\";\nimport { useZField } from \"../context\";\n\nfunction useBooleanField(field: ParsedField) {\n  const { setValue, getValues } = useFormContext();\n\n  const { id, name } = useFormField();\n  const { key, required } = field;\n  const checked = getValues(name);\n\n  function onCheckedChange(checked: boolean) {\n    setValue(name, checked, { shouldValidate: true });\n  }\n  return { required, id, key, onCheckedChange, checked };\n}\n\nexport const BooleanField: React.FC<ZFieldProps> = ({ field, path }) => {\n  const { key, ...props } = useBooleanField(field);\n  const { checkboxProps } = useZField(field, path);\n  return <Checkbox key={key} {...props} {...checkboxProps} />;\n};\n\nexport const SwitchField: React.FC<ZFieldProps> = ({ field, path }) => {\n  const { key, ...props } = useBooleanField(field);\n\n  const { switchProps } = useZField(field, path);\n  return <Switch key={key} {...props} {...switchProps} />;\n};\nexport function getBooleanFieldComponent(typeOverride?: \"switch\") {\n  if (typeOverride === \"switch\") return SwitchField;\n  return BooleanField;\n}\n",
      "type": "registry:block",
      "target": "~/zform/components/boolean-field.tsx"
    },
    {
      "path": "./zform/components/date-field.tsx",
      "content": "import React, { useEffect, useRef } from \"react\";\nimport { CalendarIcon } from \"lucide-react\";\nimport { useFormContext } from \"react-hook-form\";\n\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/components/ui/button\";\nimport { Calendar } from \"@/components/ui/calendar\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { ParsedField } from \"../core/types\";\nimport { useFormField } from \"@/components/ui/form\";\nimport { ZFieldProps } from \"../types\";\nimport { useZField } from \"../context\";\nimport { format } from \"date-fns\";\nimport { DateRange } from \"react-day-picker\";\n\nfunction formatDate(date: Date) {\n  return format(date, \"LLL dd, y\");\n}\n\nfunction useDateField(field: ParsedField) {\n  const { setValue, getValues } = useFormContext();\n  const { id, name } = useFormField();\n  const { key } = field;\n  const selected = getValues(name);\n  const onSelect = (date: Date | DateRange | undefined) => {\n    setValue(name, date, { shouldValidate: true });\n  };\n\n  return { key, id, onSelect, selected };\n}\nconst DateField: React.FC<ZFieldProps> = ({ field, path }) => {\n  const popoverTriggerRef = useRef<HTMLButtonElement>(null); // Ref for the PopoverTrigger\n\n  const { calendarProps } = useZField(field, path);\n  const { id, key, onSelect, selected } = useDateField(field);\n\n  useEffect(() => {\n    if (selected) popoverTriggerRef.current?.click();\n  }, [selected]);\n\n  return (\n    <Popover key={key}>\n      <PopoverTrigger asChild ref={popoverTriggerRef}>\n        <Button\n          variant={\"outline\"}\n          className={cn(\n            \"w-full font-normal\",\n            !selected && \"text-muted-foreground\"\n          )}\n          type=\"button\"\n        >\n          <CalendarIcon />\n          {selected ? formatDate(selected) : <span>Pick a date</span>}\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-auto p-0\" align=\"start\">\n        <Calendar\n          id={id}\n          captionLayout=\"dropdown\"\n          selected={selected}\n          {...calendarProps}\n          mode=\"single\"\n          onSelect={onSelect}\n        />\n      </PopoverContent>\n    </Popover>\n  );\n};\n\nconst RangeField: React.FC<ZFieldProps> = ({ field, path }) => {\n  const popoverTriggerRef = useRef<HTMLButtonElement>(null); // Ref for the PopoverTrigger\n\n  const { calendarProps } = useZField(field, path);\n  const { id, key, onSelect, selected } = useDateField(field);\n\n  useEffect(() => {\n    if (selected) popoverTriggerRef.current?.click();\n  }, [selected]);\n\n  return (\n    <Popover key={key}>\n      <PopoverTrigger asChild ref={popoverTriggerRef}>\n        <Button\n          variant={\"outline\"}\n          className={cn(\n            \"w-full font-normal\",\n            !selected && \"text-muted-foreground\"\n          )}\n          type=\"button\"\n        >\n          <CalendarIcon />\n          {selected?.from ? (\n            selected.to ? (\n              <>\n                {formatDate(selected.from)} - {formatDate(selected.to)}\n              </>\n            ) : (\n              formatDate(selected.from)\n            )\n          ) : (\n            <span>Pick a date</span>\n          )}\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-auto p-0\" align=\"start\">\n        <Calendar\n          id={id}\n          captionLayout=\"dropdown\"\n          defaultMonth={selected?.from}\n          selected={selected}\n          numberOfMonths={2}\n          {...calendarProps}\n          mode=\"range\"\n          onSelect={onSelect}\n        />\n      </PopoverContent>\n    </Popover>\n  );\n};\nexport const getDateFieldComponent = (typeOverride?: \"range\") => {\n  if (typeOverride === \"range\") return RangeField;\n  return DateField;\n};\n",
      "type": "registry:block",
      "target": "~/zform/components/date-field.tsx"
    },
    {
      "path": "./zform/components/number-field.tsx",
      "content": "import React from \"react\";\nimport { useFormField } from \"@/components/ui/form\";\nimport { useFormContext } from \"react-hook-form\";\nimport { ParsedField } from \"../core/types\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Minus, Plus } from \"lucide-react\";\nimport { ZFieldProps } from \"../types\";\nimport { useZField } from \"../context\";\n\nfunction useNumberField(field: ParsedField) {\n  const { register, setValue, getValues } = useFormContext();\n  const { id, name } = useFormField();\n  const { type, key, required } = field;\n  const value: number = getValues(name) || 0;\n  const increment = (step: number) => {\n    setValue(name, value + step);\n  };\n\n  const decrement = (step: number) => {\n    setValue(name, value - step);\n  };\n  return {\n    type,\n    key,\n    required,\n    id,\n    value,\n    increment,\n    decrement,\n    ...register(name, { valueAsNumber: true }),\n  };\n}\n\nexport const NumberField: React.FC<ZFieldProps> = ({ field, path }) => {\n  const { key, ...other } = useNumberField(field);\n  const { inputProps } = useZField(field, path);\n  return <Input key={key} {...other} {...inputProps} />;\n};\n\nconst StepperField: React.FC<ZFieldProps> = ({ field, path }) => {\n  const { key, id, increment, decrement, value } = useNumberField(field);\n  const { inputProps } = useZField(field, path);\n\n  const step = inputProps?.step ? Number(inputProps.step) : 1;\n  const max = inputProps?.max\n    ? Number(inputProps.max)\n    : Number.MAX_SAFE_INTEGER;\n  const min = inputProps?.min\n    ? Number(inputProps.min)\n    : Number.MIN_SAFE_INTEGER;\n\n  return (\n    <div key={key} id={id} className=\"flex items-center space-x-2\">\n      <Button\n        type=\"button\"\n        variant=\"outline\"\n        size=\"icon\"\n        onClick={() => decrement(step)}\n        aria-label=\"Decrement\"\n        disabled={min >= value}\n      >\n        <Minus />\n      </Button>\n      <Badge variant=\"outline\" className=\"size-10 text-center\">\n        <span className=\"text-lg font-semibold m-auto\">{value}</span>\n      </Badge>\n      <Button\n        type=\"button\"\n        variant=\"outline\"\n        size=\"icon\"\n        onClick={() => increment(step)}\n        disabled={max <= value}\n        aria-label=\"Increment\"\n      >\n        <Plus />\n      </Button>\n    </div>\n  );\n};\n\nexport const getNumberFieldComponent = (typeOverride?: \"stepper\") => {\n  if (typeOverride === \"stepper\") return StepperField;\n  return NumberField;\n};\n",
      "type": "registry:block",
      "target": "~/zform/components/number-field.tsx"
    },
    {
      "path": "./zform/components/object-field.tsx",
      "content": "import React from \"react\";\nimport { ZField } from \"../field\";\nimport { ParsedField } from \"../core/types\";\nimport { useZField } from \"../context\";\nimport { getDateFieldComponent } from \"./date-field\";\n\nexport const ObjectField: React.FC<{\n  field: ParsedField;\n  path: string[];\n}> = ({ field, path }) => {\n  const { className, fieldLabel, fieldDescription } = useZField(field, path);\n  return (\n    <fieldset className={className}>\n      <legend className=\"p-2\">\n        <p className=\"font-semibold\">{fieldLabel}</p>\n        <p className=\"text-sm text-muted-foreground\">{fieldDescription}</p>\n      </legend>\n      {Object.entries(field.schema!).map(([, subField]) => (\n        <ZField\n          key={`${path.join(\".\")}.${subField.key}`}\n          field={subField}\n          path={[...path, subField.key]}\n        />\n      ))}\n    </fieldset>\n  );\n};\nexport const getObjectFieldComponent = (typeOverride?: \"range\") => {\n  if (typeOverride === \"range\") return getDateFieldComponent(typeOverride);\n  return ObjectField;\n};\n",
      "type": "registry:block",
      "target": "~/zform/components/object-field.tsx"
    },
    {
      "path": "./zform/components/select-field.tsx",
      "content": "import React from \"react\";\nimport { useFormContext } from \"react-hook-form\";\n\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { ParsedField } from \"../core/types\";\nimport { useFormField } from \"@/components/ui/form\";\nimport { ZFieldProps } from \"../types\";\nimport { useZField } from \"../context\";\n\nfunction useSelectField(field: ParsedField) {\n  const { setValue, getValues } = useFormContext();\n  const { id, name } = useFormField();\n  const { key, required, options } = field;\n  const value = getValues(name);\n  const onValueChange = (value: string) => {\n    setValue(name, value, { shouldValidate: true });\n  };\n  return { key, required, id, name, onValueChange, value, options };\n}\nexport const SelectField: React.FC<ZFieldProps> = ({ field, path }) => {\n  const { key, options, ...props } = useSelectField(field);\n\n  const { selectProps } = useZField(field, path);\n  return (\n    <Select key={key} {...props} {...selectProps}>\n      <SelectTrigger>\n        <SelectValue placeholder=\"Select an option\" />\n      </SelectTrigger>\n      <SelectContent>\n        {options?.map(([value, label]) => (\n          <SelectItem key={value} value={value}>\n            {label}\n          </SelectItem>\n        ))}\n      </SelectContent>\n    </Select>\n  );\n};\nexport const getSelectFieldComponent = (typeOverride?: \"autocomplete\") => {\n  if (typeOverride === \"autocomplete\")\n    throw new Error(\"Not implemented\", { cause: { typeOverride } });\n  return SelectField;\n};\n",
      "type": "registry:block",
      "target": "~/zform/components/select-field.tsx"
    },
    {
      "path": "./zform/components/string-field.tsx",
      "content": "import React from \"react\";\nimport { useFormField } from \"@/components/ui/form\";\nimport { useFormContext } from \"react-hook-form\";\nimport { ParsedField } from \"../core/types\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { EyeIcon, EyeOffIcon } from \"lucide-react\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { ZFieldProps } from \"../types\";\nimport { useZField } from \"../context\";\n\nfunction useStringField(field: ParsedField) {\n  const { register } = useFormContext();\n  const { id, name } = useFormField();\n  const { type, key, required } = field;\n  return { type, key, required, id, ...register(name) };\n}\n\nexport const TextField: React.FC<ZFieldProps> = ({ field, path }) => {\n  const { key, ...other } = useStringField(field);\n  const { inputProps } = useZField(field, path);\n  return <Input key={key} {...other} {...inputProps} />;\n};\n\nexport const TextareaField: React.FC<ZFieldProps> = ({ field, path }) => {\n  const { key, ...other } = useStringField(field);\n  const { textareaProps } = useZField(field, path);\n  return <Textarea key={key} rows={4} {...other} {...textareaProps} />;\n};\nexport const PasswordField: React.FC<ZFieldProps> = ({ field, path }) => {\n  const [showPassword, setShowPassword] = React.useState(false);\n  const { key, ...other } = useStringField(field);\n  const { inputProps } = useZField(field, path);\n\n  return (\n    <div className=\"relative\">\n      <Input\n        key={key}\n        className=\"hide-password-toggle pr-10\"\n        {...other}\n        type={showPassword ? \"text\" : \"password\"}\n        {...inputProps}\n      />\n      <Button\n        type=\"button\"\n        variant=\"ghost\"\n        size=\"sm\"\n        className=\"absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent\"\n        onClick={() => setShowPassword((prev) => !prev)}\n      >\n        {showPassword && !other.disabled ? (\n          <EyeIcon className=\"size-4\" aria-hidden=\"true\" />\n        ) : (\n          <EyeOffIcon className=\"size-4\" aria-hidden=\"true\" />\n        )}\n        <span className=\"sr-only\">\n          {showPassword ? \"Hide password\" : \"Show password\"}\n        </span>\n      </Button>\n\n      {/* hides browsers password toggles */}\n      <style>\n        {`\n            .hide-password-toggle::-ms-reveal,\n            .hide-password-toggle::-ms-clear {\n                visibility: hidden;\n                pointer-events: none;\n                display: none;\n            }\n        `}\n      </style>\n    </div>\n  );\n};\nexport const getStringFieldComponent = (\n  typeOverride?: \"password\" | \"textarea\"\n) => {\n  if (typeOverride === \"password\") return PasswordField;\n  if (typeOverride === \"textarea\") return TextareaField;\n  return TextField;\n};\n",
      "type": "registry:block",
      "target": "~/zform/components/string-field.tsx"
    },
    {
      "path": "./zform/core/parser.ts",
      "content": "import { DefaultValues } from \"react-hook-form\";\nimport { z } from \"zod\";\nimport {\n  ParsedField,\n  inferFieldType,\n  ZodObjectOrWrapped,\n  ParsedSchema,\n} from \"./types\";\n\nfunction beautifyLabel(label: string) {\n  if (!label) {\n    return \"\";\n  }\n  let output = label.replace(/_|-/g, \" \"); // Replace all underscores with spaces (snake_case)\n  output = output.replace(/([A-Z])/g, \" $1\"); // Add spaces before capital letters (camelCase)\n  output = output.replace(/\\b\\w/g, (char) => char.toUpperCase()); // Capitalize the first letter of each word;;\n\n  // Never return a number for the label\n  // This primarily important for array fields so we don't get \"0\" as a label\n  if (!isNaN(Number(output))) {\n    return \"\";\n  }\n\n  // Ignore labels for arrays of non-objects\n  if (output === \"*\") {\n    return \"\";\n  }\n\n  return output;\n}\nfunction getDefaultValueInZodStack(schema: z.ZodTypeAny): unknown {\n  if (schema instanceof z.ZodDefault) {\n    return schema._def.defaultValue();\n  }\n\n  if (schema instanceof z.ZodEffects) {\n    return getDefaultValueInZodStack(schema.innerType());\n  }\n\n  return undefined;\n}\n\nfunction parseField(key: string, schema: z.ZodTypeAny): ParsedField {\n  const baseSchema = getBaseSchema(schema);\n  const type = inferFieldType(baseSchema);\n  const defaultValue = getDefaultValueInZodStack(schema);\n  let options: [string, string][] = [];\n\n  // Arrays and objects\n  let subSchema: ParsedField[] = [];\n  if (baseSchema instanceof z.ZodObject) {\n    subSchema = Object.entries(baseSchema.shape).map(([key, field]) =>\n      parseField(key, field as z.ZodTypeAny)\n    );\n  }\n  if (baseSchema instanceof z.ZodArray) {\n    subSchema = [parseField(\"0\", baseSchema._def.type)];\n  }\n  if (baseSchema instanceof z.ZodNativeEnum) {\n    options = Object.values<string>(baseSchema._def.values).map((v) => [\n      v,\n      beautifyLabel(v),\n    ]);\n  }\n  if (baseSchema instanceof z.ZodEnum) {\n    options = (baseSchema._def.values as string[]).map((v) => [\n      v,\n      beautifyLabel(v),\n    ]);\n  }\n  return {\n    key,\n    type,\n    required: !schema.isOptional(),\n    default: defaultValue,\n    description: baseSchema.description,\n    schema: subSchema,\n    options,\n  };\n}\n\nfunction getBaseSchema<\n  ChildType extends z.ZodAny | z.ZodTypeAny | z.AnyZodObject = z.ZodAny\n>(schema: ChildType | z.ZodEffects<ChildType>): ChildType {\n  if (\"innerType\" in schema._def) {\n    return getBaseSchema(schema._def.innerType as ChildType);\n  }\n  if (\"schema\" in schema._def) {\n    return getBaseSchema(schema._def.schema as ChildType);\n  }\n\n  return schema as ChildType;\n}\nexport function getDefaultValues(\n  schema: ZodObjectOrWrapped\n): DefaultValues<ZodObjectOrWrapped> {\n  const objectSchema =\n    schema instanceof z.ZodEffects ? schema.innerType() : schema;\n  const shape = objectSchema.shape;\n\n  const defaultValues: Record<string, unknown> = {};\n\n  for (const [key, field] of Object.entries(shape)) {\n    const defaultValue = getDefaultValueInZodStack(field as z.ZodTypeAny);\n    if (defaultValue !== undefined) {\n      defaultValues[key] = defaultValue;\n    }\n  }\n\n  return defaultValues;\n}\n\nexport function getLabel(field: ParsedField) {\n  return beautifyLabel(field.key);\n}\n\nexport function getDescriptions(field: ParsedField) {\n  return field.description;\n}\n\nfunction enhanceZodString(key: string | number, field: z.ZodString) {\n  const isOptional = field.isOptional();\n  if (!isOptional) {\n    // If the field is a string, apply the refinement with the required error for falsy string values\n    const message = field._def.errorMap?.(\n      {\n        code: \"invalid_type\",\n        expected: \"string\",\n        received: \"undefined\",\n        path: [key],\n      },\n      { data: undefined, defaultError: \"This field is required\" }\n    ).message;\n    return field.refine((val) => !!val, {\n      message,\n    });\n  }\n  return field;\n}\nfunction enhanceZodObject(\n  key: string | number,\n  field: z.ZodObject<\n    z.ZodRawShape,\n    z.UnknownKeysParam,\n    z.ZodTypeAny,\n    z.ZodTypeAny,\n    z.ZodTypeAny\n  >\n) {\n  const isOptional = field.isOptional();\n  const enhanced = z.object(createEnhancedSchemaShape(field));\n  if (isOptional) {\n    const message = field._def.errorMap?.(\n      {\n        code: \"invalid_type\",\n        expected: \"string\",\n        received: \"undefined\",\n        path: [key],\n      },\n      { data: undefined, defaultError: \"This field is required\" }\n    ).message;\n    return enhanced.refine((val) => !!val, message);\n  }\n\n  return enhanced;\n}\n\nfunction enhanceZodArray(\n  key: string | number,\n  field: z.ZodArray<z.ZodTypeAny>\n) {\n  const enhancedElement = enhanceZodField(key, field.element);\n  let copy = z.array(enhancedElement);\n  // Mapping between _def keys and ZodArray methods\n  const checksMap = {\n    exactLength: \"length\",\n    minLength: \"min\",\n    maxLength: \"max\",\n  } as const;\n\n  // Dynamically apply the checks\n  for (const [checkKey, method] of Object.entries(checksMap)) {\n    if (field._def[checkKey as \"exactLength\" | \"maxLength\" | \"minLength\"]) {\n      const check =\n        field._def[checkKey as \"exactLength\" | \"maxLength\" | \"minLength\"]!;\n      copy = copy[method](check.value, check.message);\n    }\n  }\n  return copy;\n}\n\nfunction enhanceZodField(\n  key: string | number,\n  field: z.ZodTypeAny\n): z.ZodTypeAny {\n  if (field instanceof z.ZodString) {\n    return enhanceZodString(key, field);\n  } else if (field instanceof z.ZodObject) {\n    return enhanceZodObject(key, field);\n  } else if (field instanceof z.ZodArray) {\n    return enhanceZodArray(key, field);\n  }\n  return field; // Leave other types untouched\n}\n\nfunction createEnhancedSchemaShape(\n  schema: ZodObjectOrWrapped\n): Record<string, z.ZodTypeAny> {\n  const objectSchema =\n    schema instanceof z.ZodEffects ? schema.innerType() : schema;\n  const shape = objectSchema.shape;\n  const enhancedShape: Record<string, z.ZodTypeAny> = {};\n\n  Object.keys(shape).forEach((key) => {\n    const field = shape[key];\n    enhancedShape[key] = enhanceZodField(key, field);\n  });\n  return enhancedShape;\n}\nexport function parseSchema(schema: ZodObjectOrWrapped): ParsedSchema {\n  const shape = createEnhancedSchemaShape(schema);\n\n  const fields: ParsedField[] = Object.entries(shape).map(([key, field]) =>\n    parseField(key, field as z.ZodTypeAny)\n  );\n\n  return { fields, schema: z.object(shape) };\n}\n",
      "type": "registry:block",
      "target": "~/zform/core/parser.ts"
    },
    {
      "path": "./zform/core/types.ts",
      "content": "import { ZodRawShape, ZodTypeAny, z, UnknownKeysParam } from \"zod\";\n\nexport type ZodObjectOrWrapped<\n  T extends ZodRawShape = Record<string, ZodTypeAny>\n> =\n  | z.ZodObject<T, UnknownKeysParam>\n  | z.ZodEffects<z.ZodObject<T, UnknownKeysParam>>;\n\nexport type FieldType = ReturnType<typeof inferFieldType>;\nexport interface ParsedField<T = FieldType> {\n  key: string;\n  type: T;\n  required: boolean;\n  default?: unknown;\n  description?: string;\n\n  // Field-specific\n  options?: [string, string][]; // [value, label] for enums\n  schema?: ParsedField[]; // For objects and arrays\n}\n\nexport interface ParsedSchema {\n  fields: ParsedField[];\n  schema: ZodObjectOrWrapped;\n}\n\nexport function inferFieldType(schema: z.ZodTypeAny) {\n  if (schema instanceof z.ZodObject) return \"object\";\n  if (schema instanceof z.ZodString) return \"string\";\n  if (schema instanceof z.ZodNumber) return \"number\";\n  if (schema instanceof z.ZodBoolean) return \"boolean\";\n  if (schema instanceof z.ZodDate) return \"date\";\n  if (schema instanceof z.ZodEnum) return \"select\";\n  if (schema instanceof z.ZodNativeEnum) return \"select\";\n  if (schema instanceof z.ZodArray) return \"array\";\n\n  return \"string\"; // Default to string for unknown types\n}\n",
      "type": "registry:block",
      "target": "~/zform/core/types.ts"
    }
  ]
}